import{_ as i,c as e,ab as l,o as r}from"./chunks/framework.DnBlaP3q.js";const d=JSON.parse('{"title":"现有的微前端方案","description":"","frontmatter":{},"headers":[],"relativePath":"minweb/微前端/2现有的微前端方案.md","filePath":"minweb/微前端/2现有的微前端方案.md"}'),t={name:"minweb/微前端/2现有的微前端方案.md"};function o(s,a,n,h,m,p){return r(),e("div",null,a[0]||(a[0]=[l('<h1 id="现有的微前端方案" tabindex="-1">现有的微前端方案 <a class="header-anchor" href="#现有的微前端方案" aria-label="Permalink to &quot;现有的微前端方案&quot;">​</a></h1><h2 id="_1-iframe" tabindex="-1">1. iframe <a class="header-anchor" href="#_1-iframe" aria-label="Permalink to &quot;1. iframe&quot;">​</a></h2><p>iframe大家都很熟悉，通过iframe实现的话就是每个子应用通过iframe标签来嵌入到父应用中，iframe具有天然的隔离属性，各个子应用之间以及子应用和父应用之间都可以做到互不影响。</p><p>但是iframe也有很多缺点：</p><ol><li>url不同步，如果刷新页面，iframe中的页面的路由会丢失。</li><li>全局上下文完全隔离，内存变量不共享。</li><li>UI不同步，比如iframe中的页面如果有带遮罩层的弹窗组件，则遮罩就不能覆盖整个浏览器，只能在iframe中生效。</li><li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。</li></ol><h2 id="_2-single-spa" tabindex="-1">2. single-spa <a class="header-anchor" href="#_2-single-spa" aria-label="Permalink to &quot;2. single-spa&quot;">​</a></h2><p>官网：<a href="https://zh-hans.single-spa.js.org/docs/getting-started-overview" target="_blank" rel="noreferrer">https://zh-hans.single-spa.js.org/docs/getting-started-overview</a></p><p>single-spa是最早的微前端框架，可以兼容很多技术栈。</p><p>single-spa首先在基座中注册所有子应用的路由，当URL改变时就会去进行匹配，匹配到哪个子应用就会去加载对应的那个子应用。</p><p>相对于iframe的实现方案，single-spa中基座和各个子应用之间共享着一个全局上下文，并且不存在URL不同步和UI不同步的情况，但是single-spa也有以下的缺点：</p><ol><li>没有实现js隔离和css隔离</li><li>需要修改大量的配置，包括基座和子应用的，不能开箱即用</li></ol><h2 id="_3-qiankun" tabindex="-1">3. qiankun <a class="header-anchor" href="#_3-qiankun" aria-label="Permalink to &quot;3. qiankun&quot;">​</a></h2><p>qiankun是阿里开源的一个微前端的框架，在阿里内部已经经过一批线上应用的充分检验及打磨了，所以可以放心使用。 <a href="https://qiankun.umijs.org/zh" target="_blank" rel="noreferrer">官方文档</a></p><ul><li>特点</li></ul><ol><li>html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；</li><li>完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了</li><li>strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案；</li><li>做了静态资源预加载能力；</li></ol><ul><li>不足</li></ul><ol><li>适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；</li><li>css 沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；</li><li>无法同时激活多个子应用，也不支持子应用保活；</li><li>无法支持 vite 等 esmodule 脚本运行；</li></ol><h2 id="_4-无界微前端" tabindex="-1">4. 无界微前端 <a class="header-anchor" href="#_4-无界微前端" aria-label="Permalink to &quot;4. 无界微前端&quot;">​</a></h2><p><a href="https://wujie-micro.github.io/doc/" target="_blank" rel="noreferrer">官方文档</a><a href="https://wujie-micro.github.io/demo-main-vue/react16?react16=%2Fdemo-react16%2Fhome" target="_blank" rel="noreferrer">预览demo</a></p><ul><li>特点 <ol><li>接入简单只需要四五行代码</li><li>不需要针对vite额外处理</li><li>预加载</li><li>应用保活机制</li></ol></li><li>不足 <ol><li>隔离js使用一个空的iframe进行隔离</li><li>子应用axios需要自行适配</li><li>iframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从&#39;about:blank&#39;初始化为主 应用的host，这个采用的计时器去等待的不是很优雅。</li><li>底层原理 使用shadowDom 隔离css，js使用空的iframe隔离，通讯使用的是proxy</li></ol></li></ul>',20)]))}const f=i(t,[["render",o]]);export{d as __pageData,f as default};
